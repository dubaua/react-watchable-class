/*
Что тут должно быть
1. Поддержка типизации декторатора
2. Декоратор создает прокси и кладет ее в поле по символу.
3. Прокси умеет перехватывает изменения на примитивы, массивы, (weak~)мап/сет
4. Хендлер прокси не знает как обрабатывать тот или иной случай, вместо этого, он обращается к структуре множества колбеков
она описывается следующим образом
Map<имя_поля, Обработчик_По_символу_зависимого>
Обработчик_По_символу_зависимого = это мапа, хранящая обработчик по символу компонента
Далее мы можем подписаться на изменение поля с помощью специального метода, который принимает 
имя поля, и сам колбек. Он создает символ и кладет его в мапу обработчиков имени поля, в мапу обработчиков по символу.
И возвращает функцию для отписки, отписывающуюся по созданному символу.
5. добавляет метод на класс, позволяющий подписываться на изменения

Как должно работать
Создаем класс-службу и декорируем ее.
Создаем кастомный хук. Хук принимает класс-службу и имя поля.
Хук использует одноразовый эффект при создании компонента
создает подписку на изменения класса, и умеет отписываться.
Подписка на изменения просто юзает setState с дешевым инкрементом и возвращает поле класса по имени.
Таким образом реакт знает о том, что компонент нужно перерендерить и получает свежие данные из службы

https://stackoverflow.com/questions/2233952/difference-between-the-composite-pattern-and-decorator-pattern
*/

export function watchable<T>(constructor: any): T {
  // save a reference to the original constructor
  const original = constructor;

  // the new constructor behavior
  function newConstructor(...args): any {
    console.log(`New: ${original.name}`);
    //return  original.apply(this, args);
    return new original(...args); // according the comments
  }

  // copy prototype so intanceof operator still works
  newConstructor.prototype = original.prototype;

  // return new constructor (will override original)
  return newConstructor as unknown as T;
}
